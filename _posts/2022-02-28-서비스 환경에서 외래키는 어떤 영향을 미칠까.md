---
toc: true
title: 외래키는 성능에 어떤 영향을 미칠까?
layout: post
comments: true
date: '2022-02-28 18:00:00'
categories: MySQL
---
## 외래키 (Foreign Key)란?

외래키는 MySQL에서 기본 엔진으로 사용되는 InnoDB 스토리지 엔진에서만 사용 가능한 제약조건입니다.
외래키는 서로 다른 테이블 간 부모-자식 관계를 정의하여, 데이터 변경이 발생하면 정의한 제약조건에 따라
함께 영향을 받는 특징을 가지고 있습니다.
또한, 부모-자식 관계로 정의된 컬럼에 대해 자동으로 인덱스가 생성됩니다.
## 외래키의 특징

데이터베이스에서 DML을 통해 데이터 변경이 발생하면, Lock을 소유하게 됩니다.
일반적으로 **외래키 제약조건이 없는** 테이블이라면, 다른 테이블에 대한 DML에 대해서는 Lock으로 인해 대기하지 않습니다.

하지만, **외래키 제약조건이 있는** 테이블의 경우, 부모-자식 관계로 정의된 컬럼에 대해서 두 테이블 데이터가 일치해야 하기 때문에,
외래키로 정의된 동일 데이터에 대해 DML 작업이 발생하게 되면, Lock으로 인해 대기해야 하는 상황이 발생합니다.
위 상황을 간단한 아래 테스트를 통해 확인해 볼 수 있습니다.

```sql
-- 외래키 제약조건을 가진 테스트 테이블 A, B 생성

mysql> CREATE TABLE parent_fk
(
    id   int AUTO_INCREMENT PRIMARY KEY,
    name varchar(10),
    age  int NOT NULL,
    INDEX ix_name_age (name, age)
);
Query OK, 0 rows affected (0.04 sec)

mysql> CREATE TABLE child_fk
(
    id      int AUTO_INCREMENT PRIMARY KEY,
    p_name  varchar(10),
    product varchar(15),
    p_age   int(11),
    FOREIGN KEY (p_name, p_age) REFERENCES parent_fk (name, age) ON DELETE CASCADE ON UPDATE CASCADE
);
Query OK, 0 rows affected (0.05 sec)


-- 테스트 데이터 Insert
mysql> INSERT parent_fk (name, age) VALUES ('Tom', 11), ('Martin', 29), ('David', 17), ('Grek', 40), ('Lucy', 26);
Query OK, 5 rows affected (0.02 sec)
Records: 5  Duplicates: 0  Warnings: 0

-- 외래키 제약조건 상 데이터 정합성을 유지하기 위해 부모 테이블에 없는 데이터 Insert 시 에러 발생.
mysql> INSERT child_fk (p_name, product, p_age) VALUES ('Tom', 'TV', 13);
ERROR 1452 (23000): Cannot add or update a child row: a foreign key constraint fails (`blog_test`.`child_fk`, CONSTRAINT `child_fk_ibfk_1` FOREIGN KEY (`p_name`, `p_age`) REFERENCES `parent_fk` (`name`, `age`) ON DELETE CASCADE ON UPDATE CASCADE)

mysql> INSERT child_fk (p_name, product, p_age) VALUES ('Tom', 'TV', 11);
Query OK, 1 row affected (0.03 sec)

-- 데이터 확인
mysql> SELECT * FROM parent_fk;
+----+--------+-----+
| id | name   | age |
+----+--------+-----+
|  3 | David  |  17 |
|  4 | Grek   |  40 |
|  5 | Lucy   |  26 |
|  2 | Martin |  29 |
|  1 | Tom    |  11 |
+----+--------+-----+
5 rows in set (0.01 sec)

mysql> SELECT * FROM child_fk;
+----+--------+---------+-------+
| id | p_name | product | p_age |
+----+--------+---------+-------+
|  2 | Tom    | TV      |    11 |
|  4 | David  | Desk    |    17 |
+----+--------+---------+-------+
2 rows in set (0.01 sec)

```

| 시간 | 세션 1 | 세션 2 | 비고 |
| -------- | -------- | -------- | -------- |
| 1 | ``START TRANSACTION;``   |    |    |
| 2 | ``UPDATE parent_fk SET age=80 WHERE name = 'Tom';``   |    |  name='Tom'인 부모테이블의 age 컬럼 업데이트 update  |
| 3 |   | ``START TRANSACTION;``    |    |
| 4 |   | ``UPDATE child_fk SET product = 'Notebook' WHERE p_name = 'Tom';``    |  자식 테이블의 name='Tom' product 컬럼 update  |
| 5 |   | ``ERROR 1205 (HY000): Lock wait timeout exceeded; try restarting transaction``    |  Lock으로 인해 wait_timeout 만큼 대기 후 에러 로그 발생  |


## 외래키의 성능
외래키 제약조건이 있는 테이블의 경우, 부모-자식 테이블의 데이터 정합성을 위해 Lock을 이용한다는 것을 확인할 수 있습니다.
DML이 발생할 경우, 제약 조건을 만족하는지 확인하는 과정이 추가되면, 성능에는 영향이 없을지 의문이 들었습니다.
그래서 sysbench 툴을 이용해 2개의 부모-자식 관계 테이블을 생성하고 Read-write 성능 테스트를 통해 어떤 영향이 있는지 확인해봤습니다.

먼저 아래 스크립트를 통해 테스트 데이터를 준비했습니다.

```bash
# sysbench툴을 이용한 테스트 테이블 생성
## 1억건 테이블 2개 / 약 21GB
/usr/local/sysbench/share/sysbench/oltp_read_write.lua \
	--mysql-host='[호스트 정보]' \
	--mysql-port=[Port 번호] \
	--mysql-user=master --mysql-password='[비밀번호]' \
	--mysql-db=sbtest --db-driver=mysql --tables=2 \
	--table-size=100000000 --threads=128 prepare

```
