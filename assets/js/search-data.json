{
  
    
        "post0": {
            "title": "Aurora MySQL History Length 상승을 예방하는 방법",
            "content": "History Length란? . Aurora MySQL은 On-premise MySQL 환경과 동일하게 REPEATABLE READ isolation level이 Default로 설정되어 있습니다. REPEATABLE READ 환경은 쿼리 실행 시점의 결과와, 실행 완료 시점의 결과가 동일해야 하기 때문에, 스냅샷 형태로 해당 시점의 결과를 저장하게 됩니다. 동시성이 높은 환경에서, 롱쿼리가 발생하게 되어 오랜 시간 시점데이터가 유지될수록, History Legnth 수치가 상승하게 됩니다. . History Length가 높아질수록, 오래된 데이터 스냅샷으로 인해 다른 조회 쿼리들도 시점 데이터를 통해 걸러내는 과정이 추가되면서, 검색 비효율이 발생하고 지연이 발생할 수 있습니다. 극단적으로 트래픽이 높은 서비스 환경에서는 약간의 지연으로 고객들의 불편함이 커지고, 서비스 장애의 원인이 될 수 있기 때문에, 모니터링해야 하는 필수적인 지표 중 하나입니다. . 옵션을 통한 History Length 상승 관리 . 위에서 설명드린 바와 같이, History Length가 서비스에 영향을 줄 수 있는 중요한 요소 중 하나이기 때문에, 기존 on-premise MySQL에서는 이를 관리하기 위해 아래의 옵션을 통해 긴 조회쿼리를 실행해야 하는 상황에서 session isolation level을 통해 관리가 가능했습니다. . -- Isolation level 변경 (REPATABLE READ -&gt; READ COMMITTED) mysql&gt; set session transaction isolation level read committed; . 하지만, Aurora MySQL의 공유 스토리지 환경은 위 옵션만으로는 History Length 관리가 되지 않는 문제점이 있었습니다. 공식 문서인 Aurora MySQL 격리수준을 통해 기존처럼 관리가 되지 않는 문제를 아래와 같이 표현하고 있습니다. . 리더 인스턴스의 REPEATABLE READ 격리 수준 . 기본적으로 읽기 전용 Aurora 복제본으로 구성된 Aurora MySQL DB 인스턴스에서는 항상 REPEATABLE READ 격리 수준을 사용합니다. 이 DB 인스턴스에서는 SET TRANSACTION ISOLATION LEVEL 문은 모두 무시하고 계속해서 REPEATABLE READ 격리 수준을 사용합니다. | 이 설정을 사용하기 전에 READ COMMITTED 격리의 특정 Aurora MySQL 동작을 이해하는 것이 좋습니다. Aurora 복제본 READ COMMITTED 동작은 ANSI SQL 표준을 준수합니다. 그러나 격리는 사용자에게 익숙한 일반적인 MySQL READ COMMITTED 동작보다 덜 엄격합니다. | . Aurora MySQL의 공유스토리지 환경에서도, History Length 관리를 돕기 위해 aurora_read_replica_read_committed 옵션이 제공됩니다. . -- Isolation level 변경 (REPATABLE READ -&gt; READ COMMITTED) -- SET 명령문을 이용한 세션 옵션 적용 set session aurora_read_replica_read_committed = ON; set session transaction isolation level read committed; . 해당 옵션은 Aurora MySQL 엔진 버전 1.21.x 이상 / 2.07.x 이상 버전부터 적용이 가능하며, 위 두개 구문 모두를 적용해야 Reader 장비 조회 쿼리로 인한 History Length 상승을 방지할 수 있습니다. . 옵션 성능 테스트 . 테스트 환경 . 해당 옵션이 History Length 관리에 효과가 있는지 아래 환경에서 테스트를 진행했습니다. . 테스트 장비 스펙 RDS 버전: Aurora MySQL 2.09.2 | RDS 인스턴스 타입: r6g.large | sysbench(EC2) 타입: c5.large | . | 테스트 테이블 구성 # sysbench를 이용하여 1억 건 테스트 테이블 구성 /usr/local/sysbench/bin/sysbench /usr/local/sysbench/share/sysbench/oltp_read_write.lua --mysql-host=&#39;호스트명&#39; --mysql-port=6025 --mysql-user=master --mysql-password=&#39;[비밀번호]&#39; --mysql-db=test --db-driver=mysql --tables=1 --table-size=100000000 --threads=128 prepare . | 테이블 스키마 -- 테스트 테이블 스키마 확인 (1억 건 테이블 / 59GB) mysql&gt; show create table sbtest1; | sbtest1 | CREATE TABLE `sbtest1` ( `id` int(11) NOT NULL AUTO_INCREMENT, `k` int(11) NOT NULL DEFAULT &#39;0&#39;, `c` char(120) NOT NULL DEFAULT &#39;&#39;, `pad` char(60) NOT NULL DEFAULT &#39;&#39;, PRIMARY KEY (`id`), KEY `ix_test` (`pad`,`c`), KEY `ix_test2` (`c`,`k`) ) ENGINE=InnoDB AUTO_INCREMENT=100048996 DEFAULT CHARSET=utf8mb4 | . | . 테스트 시나리오 . sysbench 툴을 이용한 트래픽 환경 조성 # 32개 스레드 /usr/local/sysbench/bin/sysbench /usr/local/sysbench/share/sysbench/oltp_read_write.lua --mysql-host=&#39;[호스트]&#39; --mysql-port=6025 --mysql-user=master --mysql-password=&#39;[비밀번호]&#39; --mysql-db=test --db-driver=mysql --delete_inserts=30 --index_updates=10 --non_index_updates=30 --threads=32 --time=300 --forced-shutdown --report-interval=1 run . | 롱쿼리를 통한 롱 트랜잭션 환경 구성 (풀테이블 스캔) mysql&gt; explain select A.* FROM test.sbtest1 as A CROSS JOIN test.sbtest1 AS B WHERE B.k &lt; 50000 ORDER BY A.k DESC LIMIT 20000 ; +-+-+-++-++-+++-+-+--+ | id | select_type | table | partitions | type | possible_keys | key | key_len | ref | rows | filtered | Extra | +-+-+-++-++-+++-+-+--+ | 1 | SIMPLE | A | NULL | ALL | NULL | NULL | NULL | NULL | 98631208 | 100.00 | Using temporary; Using filesort | | 1 | SIMPLE | B | NULL | index | NULL | ix_test2 | 484 | NULL | 98631208 | 33.33 | Using where; Using index; Using join buffer (Block Nested Loop) | +-+-+-++-++-+++-+-+--+ 2 rows in set, 1 warning (0.00 sec) . | 옵션 적용 여부에 따른, History Length 상승 비교 옵션 미적용 시나리오 mysql&gt; select A.* FROM test.sbtest1 as A CROSS JOIN test.sbtest1 AS B WHERE B.k &lt; 50000 ORDER BY A.k DESC LIMIT 20000; . | 옵션 적용 시나리오 mysql&gt; set session aurora_read_replica_read_committed = ON; Query OK, 0 rows affected (0.01 sec) mysql&gt; set session transaction isolation level read committed; Query OK, 0 rows affected (0.02 sec) mysql&gt; select A.* FROM test.sbtest1 as A CROSS JOIN test.sbtest1 AS B WHERE B.k &lt; 50000 ORDER BY A.k DESC LIMIT 20000; . | . | . 결론 . 운영환경에서, 위 옵션 적용을 통해 Reader 장비에서 조회쿼리로 인한 History Length 상승을 예방할 수 있다는 걸 확인할 수 있었습니다. History Length로 인해 크리티컬한 서비스 환경이라면, 조회 쿼리에 대해 해당 옵션 적용이 유용할 것으로 보입니다. | .",
            "url": "https://martin-son.github.io/Martin-IT-Blog/aurora/mysql/2022/07/10/Aurora-MySQL-History-Length-%EC%98%81%ED%96%A5%EB%8F%84-%EC%B5%9C%EC%86%8C%ED%99%94.html",
            "relUrl": "/aurora/mysql/2022/07/10/Aurora-MySQL-History-Length-%EC%98%81%ED%96%A5%EB%8F%84-%EC%B5%9C%EC%86%8C%ED%99%94.html",
            "date": " • Jul 10, 2022"
        }
        
    
  
    
        ,"post1": {
            "title": "Aurora Quorum 모델",
            "content": "Aurora Storage 모델 . AWS에서 분산 시스템을 구성하는 쿼럼(=Quorum)에 대해 정리해보려 합니다. . . Aurora Storage는 위 그림과 같이 총 6개의 복제본으로 구성되어 있으며 특징은 아래와 같습니다. . 3개의 Zone에 대해 각각 2개의 스토리지 영역으로 구성 | 스토리지 데이터 정합성을 보장하기 위해 쿼럼 모델을 사용 | 쓰기 작업의 완료 최소 노드 수: 6개중 4개 / 읽기 작업 완료 최소 노드 수: 6개중 3개 | 쿼럼(=Quorum) 모델 . 쿼럼 모델은 여러 노드가 존재하는 클러스터 내부에서 데이터의 정합성을 보장하면서, 특정 노드에 장애가 발생했을 경우에도 문제없는 서비스 환경을 제공하기 위한 모델입니다. . 데이터 정합성에 대한 보장과 동시에 특정 작업의 완료 여부를 판단을 위해 제약조건이 존재합니다. 특정 작업의 완료를 판단하기 위한 최소 노드 수는 아래 표와 같습니다. . 총 노드 수 (Nt) 최소 Read 노드 수 (=Nr) 최소 Write 노드 수 (=Nw) . 1 | 1 | 1 | . 2 | 1 | 2 | . 3 | 2 | 2 | . 4 | 2 | 3 | . 5 | 3 | 3 | . 6 | 3 | 4 | . 7 | 4 | 4 | . 위의 최소 노드 수 기준은 아래 쿼럼모델의 제약조건을 만족하는 완료조건입니다. . Nt &lt; Nr + Nw (총 노드 수 &lt; 최소 읽기 노드 수 + 최소 쓰기 노드 수) | Nw &gt; Nt / 2 (최소 쓰기 노드 수 &gt; 총 노드 수의 절반) | 이론상, 현재 Aurora Storage 모델을 구성하는 6개 쿼럼모델에서 읽기 작업은 3개 노드의 장애까지 정상적인 서비스가 가능하며 쓰기 작업은 2개 노드 장애에 대비가 되어 있습니다. . 또한 Zone을 세개로 분산시켜, 하나의 지역(=Zone)에 정전이나 재해가 발생하게 되더라도 남은 2개 지역(=4개 노드)을 통해 정상적인 서비스를 할 수 있도록 구성되어 있습니다. . 쿼럼모델 Latency 개선을 위한 Aurora 아키텍처 . 쿼럼 구조로 정합성과 가용성 두가지 모두를 챙길 수 있지만, 이러한 구조적 특성으로 버퍼풀에 없는 데이터에 대한 조회 요청을 받게되면 쿼럼 모델의 제약조건에 따라 최소 3개 이상의 노드에서 완료(=ACK) 신호를 받기 위해 6개 노드를 무작위로 찾게 되면, Read Latency가 발생하게 됩니다. . . 이런 Read Latency를 최소화 하기 위해 Aurora에서는 LSN을 이용해 노드별 우선순위를 결정합니다. 예를 들어 특정 쓰기가 발생하면 최소 4개의 노드에서 쓰기 완료(=ACK) 응답을 받으면 커밋으로 인지하게 되는데요. 해당 데이터에 대한 읽기 요청이 들어왔을 때 먼저 완료된 4개 노드에 대해서 우선적으로 읽기 요청을 보내는데, 노드별 LSN의 크기를 이용하여 가장 최신 상태인 노드를 판단합니다. 이를 통해 데이터가 있는 노드에 우선적으로 접근하여 불필요한 접근을 줄여 Read Latency를 최소화합니다. . Latency를 최소화하더라도 여전히 쿼럼 구조는 Latency가 발생하므로 쿼럼 읽기 작업이 항상 발생하지 않으며 아래와 같은 상황에서만 발생합니다. . 메모리에 없는(=캐싱되지 않은) 데이터에 대한 조회 요청 | Master 인스턴스 재시작 | Reader 인스턴스가 Master로 승격 | Aurora 쿼럼모델 비용 개선 아키텍처 . Aurora 쿼럼모델은 6개의 노드를 사용하며, 만약 모든 노드가 전체 데이터를 소유한다면 일반적인 스토리지 구조에 비해 6배 크기의 데이터 베이스를 소유해야 합니다. 그만큼 비용도 크게 증가(=약 6배)하게 되므로 이런 구조를 개선하기 위해 Aurora에서는 풀 세그먼트 + 테일 세그먼트 구조를 이용합니다. . 풀 세그먼트(=Full Segment) : 데이터 페이지 + Redo Log | 테일 세그먼트(=Tail Segment): Redo Log | . Aurora 데이터베이스 볼륨은 10GB 데이터 세그먼트 단위로 구성됩니다. 데이터 세그먼트는 6개의 노드로 복제되어 보관되며, 같은 6개의 세그먼트 Set을 보호그룹(=Security Group)이라 합니다. 6개의 세그먼트 Set은 3개의 풀 세그먼트, 3개의 테일 세그먼트로 구성됩니다. . . 위 그림과 같이 각 Zone에는 두 개의 노드가 포함되며, Zone별로 풀 세그먼트 1 + 테일 세그먼트 1로 구성되어 있습니다. 이를 통해 기존 예상 증가 금액 대비 50% 절감이 가능해집니다. (6배 -&gt; 약 3배) . 일반적인 구조와 다르게 풀 + 테일 세그먼트가 혼합된 Aurora 아키텍처에서는 쓰기/읽기 작업 완료를 위해 아래의 특정 조건을 만족해야 합니다. . 쓰기 작업 (6개 중 4개의 노드 ACK) 1개 이상의 풀 세그먼트 + 테일 세그먼트 | . | 읽기 작업 (6개 중 3개 노드 ACK) 1개의 풀 세그먼트 + 테일 세그먼트 | . | 또한 조회 Latency를 최소화하기 위한 방법도 LSN을 통해 가장 최신의 풀 세그먼트를 소유한 노드를 이용하여 요청을 처리하게 됩니다. 만약 세그먼트에 Corrupt가 발생하면, 풀세그먼트와 테일 세그먼트를 이용하여 쉽게 복구도 가능합니다. . 장애 관리를 위한 Aurora Quorum Membership 개념 . Aurora는 쿼럼 집합(=Quorum Membership) 개념을 이용하여 장애 상황을 관리합니다. 세그먼트에 변화가 발생할 때마다, 독립적인 상태값인 epoch 라는 값이 증가합니다. 이 값을 통해 쿼럼 집합 구성원들의 상태를 판단합니다. . 아래 간단한 예시를 통해 쿼럼 멤버십에 대해 설명드리겠습니다. 기존 구성원(=ABCEDF) 중 F에 장애가 일어났을 때, 아래와 같은 과정을 거치게 됩니다. . F 구성원에 장애 발생 | 신규 G 구성원 준비 / F 구성원 복구 프로세스 진행 | 기존 구성원 집합(=ABCDEF), 신규 구성원 집합(=ABCDEG)에 요청(읽기/쓰기) 전달 | 더 신속한 응답을 주는 집합을 선택 후, 나머지 예비 집합 제거 | 각 상태에 따라 Epoch 값이 1 ~ 3으로 증가하는 것을 위 그림에서 확인할 수 있습니다. 만약 위와 달리, F 구성원의 복구가 G 구성원의 준비보다 빠르게 되었다면 ABCDEF 쿼럼 집합이 선택됩니다. . 위와 같이 장애에 대한 멤버십 교체가 진행 도중에도 사용자 요청(읽기/쓰기)은 정상적으로 진행됩니다. Epoch를 이용한 쿼럼집합 개념을 통해 장애 내구성을 높이고, 사용자에게 불편을 최소화할 수 있는 아키텍처 구조를 지니고 있습니다. . 정리를 마치며 . Aurora 아키텍처에서 사용되는 쿼럼 모델에 대해 아래 참조링크에 자세하게 정리된 글이 있어, 해당 내용에 대해 정리해봤습니다. 현재 제가 글을 정리하면서도 이해가 부족한 부분이 있지만, 좀 더 쉽고 간편하게 Aurora 쿼럼 모델을 정리해보자! 라는 목적을 가지고 정리할 수 있어 좋은 경험이었다고 생각됩니다. . 참조 링크 . Amazon Aurora 내부 들여다보기(1) – 쿼럼 및 상관 오류 해결 방법 | Amazon Aurora 내부 들여다보기(2) – 쿼럼 읽기 및 상태 변경 | Amazon Aurora 내부 들여다보기(3) – 쿼럼 집합을 이용한 비용 절감 방법 | Amazon Aurora 내부 들여다보기(4) – 쿼럼 구성원 | .",
            "url": "https://martin-son.github.io/Martin-IT-Blog/aurora/stoarge/quorum/aws/2022/04/30/Aurora-Quorum-%EB%AA%A8%EB%8D%B8.html",
            "relUrl": "/aurora/stoarge/quorum/aws/2022/04/30/Aurora-Quorum-%EB%AA%A8%EB%8D%B8.html",
            "date": " • Apr 30, 2022"
        }
        
    
  
    
        ,"post2": {
            "title": "SSD vs HDD 성능 차이 테스트",
            "content": "디스크 타입에 따른 성능 . EBS (=Elastic Block Store)는 저장 매체로 크게 두가지 종류로 나뉘고 아래와 같이 세분화된 종류로 나뉩니다. . . 위의 표에서 분명한 차이를 확인하기 위해, HDD중 성능이 가장 낮은 sc1(=Cold HDD)와 SSD중 성능이 제일 좋은 gp3(=SSD) 장비에 sysbench 툴을 이용한 성능 비교를 진행했습니다. . sysbench를 이용한 File I/O 성능 비교 . 성능 비교 환경 구성을 위해 두 가지 EBS(HDD, SSD)를 추가 후 마운트합니다. . ## 마운트할 디스크 확인. $ lsblk -f NAME FSTYPE LABEL UUID MOUNTPOINT xvda └─xvda1 xfs / 518d317e-9b1a-43aa-8b7c-850dd3510341 / xvdf xfs 7ab58089-47e5-4667-b68c-45a6f3d2262f xvdg xfs c49943b6-68ba-47d5-ad57-ba56a6852ef2 xvdh xfs 60a2fae0-05d5-4690-96d4-10b9f8784543 ## 디스크 Mount $ sudo mount dev/xvdg /tmp_hdd $ sudo mount dev/xvdh /tmp_ssd_gp3 ## Mount 확인 Filesystem Size Used Avail Use% Mounted on devtmpfs 2.0G 0 2.0G 0% /dev tmpfs 2.0G 0 2.0G 0% /dev/shm tmpfs 2.0G 428K 2.0G 1% /run tmpfs 2.0G 0 2.0G 0% /sys/fs/cgroup /dev/xvda1 32G 17G 16G 51% / tmpfs 395M 0 395M 0% /run/user/1001 /dev/xvdg 300G 339M 300G 1% /tmp_hdd /dev/xvdh 300G 339M 300G 1% /tmp_ssd_gp3 . 이후 디스크별 File I/O 테스트를 진행하기 위해, sysbench 파일을 복사합니다. . ## sysbench 파일 복사 $ cp -R /usr/share/sysbench /tmp_ssd_gp3/ $ cp -R /usr/share/sysbench /tmp_hdd/ # 각 디스크에서 File I/O 테스트 환경 구축 $ sysbench --test=fileio --file-total-size=8G prepare -rw- 1 root root 67108864 Aug 3 05:07 test_file.57 -rw- 1 root root 67108864 Aug 3 05:07 test_file.58 -rw- 1 root root 67108864 Aug 3 05:07 test_file.59 -rw- 1 root root 67108864 Aug 2 09:25 test_file.6 -rw- 1 root root 67108864 Aug 3 05:07 test_file.60 # 각 디스크에서 file I/O 테스트 실행 $ sysbench fileio --file-total-size=8G --file-test-mode=rndrw --max-time=30 --report-interval=1 . file-test-mode=rndrw 옵션을 사용해, Random I/O (읽기, 쓰기) 성능 차이를 비교한 결과는 아래와 같습니다. . 디스크 타입별 mysql 임시테이블 Insert 성능 비교 . 위 테스트는 sysbench 툴을 이용하여 간접적으로 성능 차이를 확인했습니다. 실제 mysql을 사용하면서 디스크 타입에 따라 성능 차이가 어떻게 나는지 확인하기 위해 임시테이블에 단건 Insert 1000만 건 하는 SP를 생성하여, 완료 시간 기준으로 성능을 비교해봤습니다. . -- 소요시간 기록 테이블 생성 CREATE TABLE `time_table` ( `duration_sec` int(11) DEFAULT NULL, `cnt` int(11) DEFAULT NULL ) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_unicode_ci; -- SP 스크립트 CREATE DEFINER = `root`@`%` PROCEDURE `diskio_test`() BEGIN DECLARE cnt int DEFAULT 1; DECLARE begin_time datetime; DECLARE end_time datetime; -- MyISAM 임시테이블 (디스크 directory 사용) 생성 -- Engine=MyISAM 명시하지 않을 시 InnoDB 엔진을 사용하며, ibtmp1 (데이터파일 위치)에 생성되어 디스크 성능 테스트 실패 CREATE TEMPORARY TABLE disk_tmp ( id int AUTO_INCREMENT PRIMARY KEY, calendar date, num int, num_2 int, Index idx_calendar (Calendar), index idx_num (num) ) ENGINE = MyISAM; SELECT NOW() INTO begin_time; WHILE (cnt &lt;= 10000000) -- 단건 Insert 1000만 건. DO INSERT disk_tmp(calendar, num, num_2) VALUES((CURRENT_DATE - INTERVAL FLOOR(RAND() * 14) DAY), cast(rand()*100 as unsigned), cast(rand()*100 as unsigned)) ; SET cnt = cnt + 1; end while; SELECT NOW() INTO end_time; INSERT INTO time_table SELECT TIMESTAMPDIFF(SECOND, begin_time, end_time), cnt; DROP TEMPORARY TABLE disk_tmp; END; call diskio_test(); . 위 SP를 만든 후, 실제 운영환경과 같이 병렬로 Insert가 발생하는 환경을 재현하기 위해 백그라운드 프로세스로 위 SP를 10개 세션에서 병렬로 실행했습니다 . $ vi sp_insert.sh # sp 실행 구문 mysql -umaster -p[비밀번호ㅑi -h[호스트] -P[포트] -e&quot;call test.diskio_test();&quot; . $ vi disk_io.sh # 병렬 sp 실행 for ((i=0; i&lt;10; i++)); do nohup sh sp_insert.sh &amp; sleep 1 done . 위 스크립트를 실행하여 얻은 결과를 그래프로 비교한 결과는 아래와 같습니다. . 두 가지 테스트를 통해 아래와 같은 사실을 확인할 수 있었습니다. . SSD (gp3) vs Cold HDD 8GB 기준 File I/O 성능 비교 시, 약 45배 정도의 성능 차이가 발생. | File I/O 차이만큼 디스크 I/O로 인한 Sorting 쿼리 성능 차이가 나진 않았지만, (1.6배) 병렬 세션 수에 비례해서 성능차이가 증가. | Random I/O 성능면에서 SSD가 HDD보다 훨씬 뛰어남 |",
            "url": "https://martin-son.github.io/Martin-IT-Blog/mysql/storage/2022/03/28/SSD-vs-HDD-%EC%84%B1%EB%8A%A5-%EC%B0%A8%EC%9D%B4-%ED%85%8C%EC%8A%A4%ED%8A%B8.html",
            "relUrl": "/mysql/storage/2022/03/28/SSD-vs-HDD-%EC%84%B1%EB%8A%A5-%EC%B0%A8%EC%9D%B4-%ED%85%8C%EC%8A%A4%ED%8A%B8.html",
            "date": " • Mar 28, 2022"
        }
        
    
  
    
        ,"post3": {
            "title": "트랜잭션과 잠금 (Real Mysql 8.0)",
            "content": "트랜잭션이란? . 논리적인 작업의 가장 작은 단위로, 작업의 일관성을 보장해주기 위한 단위입니다. 이러한 특성에 의해 작업이 부분적으로 실패하거나 성공하지 않고, 완전히 성공 또는 실패하게 됩니다. . 트랜잭션의 특성 . 트랜잭션에는 아래 네가지 특성이 존재하며 각 특성의 앞글자를 따서 ACID로 불립니다. . 원자성 (Atomicity) 트랜잭션이 하나의 수행단위이며, 완전히 수행(Commit) 되거나 전혀 수행되지 않아야 합니다(Rollback) | . | 일관성 (Consistency) 트랜잭션이 끝난 전후로 데이터베이스는 항상 일관된 상태(제약조건 만족)를 유지해야 합니다 | . | 고립성 (Isolation) 서로 다른 트랜잭션은 독립적이며 간섭할 수 없는 상태입니다. | . | 지속성 (Durability) 트랜잭션이 Data를 변경시킨 뒤 Commit 되면 이후 데이터는 손실되지 않고 유지됩니다. | . | 트랜잭션 특성에 따른 결과 차이 . MySQL에서 대부분 사용되는 엔진은 InnoDB입니다. InnoDB는 트랜잭션을 지원하는 스토리지 엔진이며, Default 스토리지 엔진입니다. | MySQL에서 사용가능 한 MyISAM 엔진은 트랜잭션을 지원하지 않으며, 그로 인해 데이터 정합성 보장이 되지 않습니다. | 트랜잭션 지원 여부에 따라 달라지는 결과에 대해 아래 테스트를 이용해 확인해봤습니다. MyISAM 테이블의 경우, 트랜잭션이 실패했지만 결과가 부분적으로 성공 (=Partial Update) | . | . -- myisam 테이블 생성 mysql&gt; CREATE TABLE tab_myisam ( fdpk INT NOT NULL, PRIMARY KEY (fdpk) ) ENGINE=MyISAM; Query OK, 0 rows affected (0.02 sec) mysql&gt; INSERT INTO tab_myisam (fdpk) VALUES (3); Query OK, 1 row affected (0.01 sec) -- innodb 테이블 생성 mysql&gt; CREATE TABLE tab_innodb ( fdpk INT NOT NULL, PRIMARY KEY (fdpk) ) ENGINE=InnoDB; Query OK, 0 rows affected (0.03 sec) mysql&gt; INSERT INTO tab_innodb (fdpk) VALUES (3); Query OK, 1 row affected (0.01 sec) -- PK 중복 에러가 발생하도록, (1,2,3) Insert mysql&gt; INSERT INTO tab_myisam (fdpk) VALUES (1), (2), (3); ERROR 1062 (23000): Duplicate entry &#39;3&#39; for key &#39;tab_myisam.PRIMARY&#39; mysql&gt; INSERT INTO tab_innodb (fdpk) VALUES (1), (2), (3); ERROR 1062 (23000): Duplicate entry &#39;3&#39; for key &#39;tab_innodb.PRIMARY&#39; -- Insert 작업 실패 후, 테이블 데이터 확인 mysql&gt; SELECT * FROM tab_myisam; ++ | fdpk | ++ | 1 | | 2 | | 3 | ++ 3 rows in set (0.00 sec) mysql&gt; SELECT * FROM tab_innodb; ++ | fdpk | ++ | 3 | ++ 1 row in set (0.01 sec) . 잠금(Lock) . 잠금이란, 다중 트랜잭션 환경에서 데이터 일관성을 유지할 수 있게 마련된 장치입니다. 잠금 동작은 트랜잭션 Isolation Level에 따라 영향을 받습니다. 각 Isolation level에 따른 특징은 아래 링크를 참조하시면 됩니다. MySQL 기본 Isolation Level은 Reapeatable Read입니다. . MySQL에서 잠금은 크게 아래 두 가지 레벨로 분류됩니다. . 스토리지 엔진 레벨 모든 스토리지 엔진에 영향을 주는 잠금 (ex) 테이블 Lock, 메타데이터 Lock, 네임드 Lock | MySQL 엔진 레벨 스토리지 엔진 상호 간 영향을 주지 않는 잠금 (ex) 스토리지 엔진 잠금 이외에 모든 Lock | 잠금의 종류 . 글로벌 락 . 글로벌 락은 FLUSH TABLES WITH READ LOCK 명령어를 통해 획득할 수 있으며, 현재 MySQL에서 제공하는 Lock 중 가장 큽니다. | 한 세션에서 글로벌 락을 소유할 경우, 조회를 제외한 모든 DDL, DML 세션이 대기하게 됩니다. | 동일 오브젝트가 아닌 다른 오브젝트에 대한 모든 접근이 영향을 받습니다. | 일관된 데이터를 mysqldump툴을 이용한 백업을 받을 때 사용되는 Lock입니다. (옵션에 따라 조절 가능) | . -- Session 1 mysql&gt; FLUSH TABLES WITH READ LOCK; Query OK, 0 rows affected (0.02 sec) -- Session 2 (SELECT, DML, DDL 시도) mysql&gt; SELECT * FROM tab_innodb; ++ | fdpk | ++ | 3 | ++ 1 row in set (0.00 sec) mysql&gt; INSERT INTO tab_innodb VALUES (1), (2), (4); ERROR 1205 (HY000): Lock wait timeout exceeded; try restarting transaction mysql&gt; ALTER TABLE tab_innodb ADD add_col varchar(10), ALGORITHM = INPLACE, LOCK = NONE; ERROR 1205 (HY000): Lock wait timeout exceeded; try restarting transaction -- 글로벌 Lock으로 인해 조회 쿼리를 제외한 모든 쿼리가 실패한다. . 백업 락 . InnoDB의 경우, 트랜잭션을 지원하며 일관된 상태를 보장하므로 모든 데이터 변경 작업을 멈추는 것이 비효율적입니다. | 글로벌 락에 비해 좀 더 가벼운 락의 필요성이 생기게 되어 새로 도입된 Lock입니다. | 백업 락이 걸려있을 경우, 데이터 조회, 변경은 가능하며 아래 명령어들은 잠금에 의해 영향을 받습니다. 스키마 관련 작업 (DDL) | REPAIR TABLE / OPTIMIZE TABLE | 사용자 관리 / 비밀번호 변경 | . | Replica에서 Xtrabackup 툴을 이용한 백업 도중 기존에는 DDL 실행 시, 백업이 실패했지만 백업 락을 이용해 DDL이 실행되더라도 백업은 성공하고, 복제는 멈추게 됩니다. | . -- Session 1 mysql&gt; LOCK INSTANCE FOR BACKUP; Query OK, 0 rows affected (0.00 sec) -- Session 2 (SELECT, DML, DDL 시도) mysql&gt; START TRANSACTION; Query OK, 0 rows affected (0.00 sec) mysql&gt; INSERT INTO tab_innodb VALUES (1), (2), (4); Query OK, 3 rows affected (0.01 sec) Records: 3 Duplicates: 0 Warnings: 0 mysql&gt; ROLLBACK; Query OK, 0 rows affected (0.01 sec) mysql&gt; ALTER TABLE tab_innodb ADD add_col varchar(10), ALGORITHM = INPLACE, LOCK = NONE; ERROR 1205 (HY000): Lock wait timeout exceeded; try restarting transaction -- 백업 Lock으로 인해 DDL은 실패 . 테이블 락 . 개별 테이블 단위의 잠금입니다. | LOCK TABLES [테이블명] [READ | WRITE] 명령어를 이용해 명시적으로 잠금을 획득합니다. [실제 운영에서 사용되는 경우는 거의 없습니다] . | InnoDB 엔진 테이블의 경우, 레코드 기반 잠금을 지원하여 DML 작업에서 테이블 Lock은 발생하지 않습니다. 특정 유형의 DDL 실행 시, 잠금이 발생합니다. ALGORITHM=INPLACE, LOCK=NONE 옵션을 이용해 작업 유형별 Online DDL이 가능한 경우합 있습니다. . | . 네임드 락 . 네임드락은 GET_LOCK() 함수를 이용하여 특정 문자열에 대한 잠금 획득이 가능합니다. | 데이터베이스 관련 오브젝트가 아닌, 단순 사용자 지정 문자열에 대한 잠금입니다. | . 메타데이터 락 . 메타데이터 락은 객체 이름이나 구조를 변경 (ex. DDL, RENAME)할 때 잠금을 획득합니다. | 해당 Lock이 걸린 객체에 대해, DML이나 DDL은 불가합니다. | performance_schema.metadata_locks 테이블을 통해 확인 가능합니다. 8.0 버전으로 업그레이드 되면서 Default로 활성화되도록 변경됐습니다. | . | . -- 테스트 테이블 생성 &amp; 1000만 건 데이터 생성 mysql&gt; CREATE TABLE `lock_table` ( `id` int NOT NULL AUTO_INCREMENT, `calendar` date DEFAULT NULL, `num` int DEFAULT NULL, `num_2` int DEFAULT NULL, PRIMARY KEY (`id`), KEY `idx_calendar` (`calendar`), KEY `idx_num` (`num`) ) ENGINE=InnoDB AUTO_INCREMENT=10026856 DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_unicode_ci; mysql&gt; INSERT lock_table(calendar, num, num_2) SELECT (CURRENT_DATE - INTERVAL FLOOR(RAND() * 14) DAY), cast(rand() * 100 as unsigned), cast(rand() * 100 as unsigned) FROM information_schema.TABLES a CROSS JOIN information_schema.TABLES B CROSS JOIN information_schema.TABLES C LIMIT 10000000; Query OK, 10000000 rows affected (2 min 28.57 sec) Records: 10000000 Duplicates: 0 Warnings: 0 -- Session 1 (INDEX 생성 시도) mysql&gt; ALTER TABLE lock_table ADD INDEX lock_idx3 (calendar, num_2); -- Session 2 (metadata Lock 정보 확인) mysql&gt; SELECT OBJECT_TYPE, OBJECT_SCHEMA, OBJECT_NAME, LOCK_TYPE, SOURCE, OWNER_THREAD_ID FROM performance_schema.metadata_locks WHERE OBJECT_SCHEMA &lt;&gt; &#39;performance_schema&#39;; +-++--++--+--+ | OBJECT_TYPE | OBJECT_SCHEMA | OBJECT_NAME | LOCK_TYPE | SOURCE | OWNER_THREAD_ID | +-++--++--+--+ | SCHEMA | test | NULL | INTENTION_EXCLUSIVE | sql_base.cc:5399 | 92 | | TABLE | test | lock_table | SHARED_UPGRADABLE | sql_parse.cc:6162 | 92 | | TABLE | test | #sql-28c7_30 | EXCLUSIVE | sql_table.cc:16434 | 92 | +-++--++--+--+ 3 rows in set (0.02 sec) . 레코드 락 . 테이블 인덱스 레코드별로 잠금을 획득합니다. | 인덱스가 없는 레코드의 경우, InnoDB에서는 내부적으로 auto_inc PK를 생성해 레코드 잠금을 획득합니다. | 레코드 잠금은 Primary Key, Unique Key을 사용하는 작업에서 할당됩니다. | 레코드 락의 종류에는 세 가지가 존재합니다. S-lock : 다른 트랜잭션이 S-lock을 소유한 오브젝트에 대해 S-lock만 획득 가능한 Lock입니다. | X-lock : 다른 트랜잭션이 X-lock을 소유한 오브젝트에 대해 S-lock, X-lock을 획득할 수 없도록 제한합니다. | Intention-lock : Row-level / Table-level 락이 함께 사용되는 다중 잠금 계층을 지원합니다. Intention Shared Lock (IS) : 해당 테이블 각 행에, S-lock 설정 | Intention Exclusive Lock (IX) : 해당 테이블 각 행에 X-lock 설정 Intention Lock (의도락)을 통해 어떤 Lock을 획득할 것인지 미리 알려, 트랜잭션의 접근을 효과적으로 제어하는 방법입니다. 그러므로 Intention Lock을 Table-Level로 건 후, Row-Level Lock을 할당합니다. | . | | . | . . 서로 다른 두 트랜잭션이 호환성으로 인해 충돌할 경우, 선행 트랜잭션이 잠금해제할 때까지 대기합니다. 각 트랜잭션이 서로 소유한 Lock에 대해 상호 대기할 경우, Deadlock이 발생합니다. . 갭(GAP) 락 . 레코드 사이의 일정 구간에 부여하는 Lock을 의미합니다. (ex) SELECT * FROM table WHERE a BETWEEN 5 and 10 FOR UPDATE | 위 예제와 같은 경우, 5~10 범위에 대해 Insert가 불가합니다. (기본 Isolation-level인 READ-REPEATABLE의 경우) | . | READ-COMMITTED isolation-level에서는 갭락이 비활성화 됩니다. | 해당 잠금이 할당된 구간에 Insert 되는 것을 방지합니다. | 넥스트키 락의 일부로 자주 사용됩니다. | . 넥스트 키 락 . 레코드 락 + 갭 락 형태의 잠금을 의미합니다. | 해당 락은 binlog 기반으로 Replica 장비에서 실행될 때 데이터 일관성을 보장하기 위해 고안된 Lock입니다. | 넥스트 키 락과 갭 락으로 인해, 데드락이 발생하거나 대기가 발생하는 경우가 있어, 최대한 줄이는 것이 좋습니다. | . -- 테스트 테이블 생성 * 데이터 Insert mysql&gt; CREATE TABLE next_key (A int NOT NULL AUTO_INCREMENT PRIMARY KEY, b int DEFAULT NULL, c char(1) DEFAULT &#39;Y&#39;, INDEX ix_b(b)); Query OK, 0 rows affected (0.03 sec) mysql&gt; INSERT INTO next_key (b, c) VALUES (1,&#39;N&#39;), (4,&#39;S&#39;), (10, NULL),(11, &#39;Y&#39;), (14,&#39;Y&#39;), (15, &#39;N&#39;); Query OK, 6 rows affected (0.02 sec) Records: 6 Duplicates: 0 Warnings: 0 -- 데이터 확인 mysql&gt; SELECT * FROM next_key; ++++ | A | b | c | ++++ | 1 | 1 | N | | 2 | 4 | S | | 3 | 10 | NULL | | 4 | 11 | Y | | 5 | 14 | Y | | 6 | 15 | N | ++++ 6 rows in set (0.01 sec) -- Session 1 mysql&gt; START TRANSACTION; Query OK, 0 rows affected (0.01 sec) mysql&gt; SELECT * FROM next_key WHERE b BETWEEN 5 AND 13 FOR UPDATE; ++++ | A | b | c | ++++ | 3 | 10 | NULL | | 4 | 11 | Y | ++++ 2 rows in set (0.03 sec) -- Session 2 (b 데이터 범위별 Insert 실행) mysql&gt; INSERT INTO next_key (b,c) VALUES (3, &#39;S&#39;); Query OK, 1 row affected (0.01 sec) -- 4 &lt;= b &lt; 14 Lock으로 인해 wait_timeout 발생 mysql&gt; INSERT INTO next_key (b,c) VALUES (4, &#39;A&#39;); ERROR 1205 (HY000): Lock wait timeout exceeded; try restarting transaction mysql&gt; INSERT INTO next_key (b,c) VALUES (10, &#39;A&#39;); ERROR 1205 (HY000): Lock wait timeout exceeded; try restarting transaction mysql&gt; INSERT INTO next_key (b,c) VALUES (13, &#39;A&#39;); ERROR 1205 (HY000): Lock wait timeout exceeded; try restarting transaction -- b &lt; 4 / b &gt;=14 Lock의 영향을 받지 않고 Insert 성공 mysql&gt; INSERT INTO next_key (b,c) VALUES (14, &#39;A&#39;); Query OK, 1 row affected (0.02 sec) . 자동 증가 락 . AUTO_INCREMENT 속성을 가진 컬럼에 대해 채번을 위해 사용하는 락입니다. | 해당 Lock은 테이블 수준의 잠금이 사용됩니다. | Insert, Replace와 같이 새로운 값을 저장하는 쿼리에서만 사용됩니다. . | 관련 옵션 innodb_autoinc_lock_mode=0 모든 Insert문장에 자동 증가 락을 사용 | . | innodb_autoinc_lock_mode=1 [5.7이하 기본값] 단순 Insert문 (INSERT INTO ~ VALUES)처럼 몇건이 Insert될지 예측이 되는 경우, 훨씬 가볍고 빠른 래치 (=mutex)를 이용해 처리합니다. | insert ~ select문과 같이 몇 건인지 알 수 없을 경우 자동 증가 락을 할당합니다. | 대량 Insert가 발생할 때, 한번에 여러 개의 채번값을 할당하여 사용합니다. | 사용되지 못할 경우 값을 버리고 다음 번호를 할당하는데 이 경우 채번값이 번호가 연속되지 않는 케이스가 발생할 수 있습니다. | . | innodb_autoinc_lock_mode=2 [8.0이상 기본값] 자동 증가 락을 사용하지 않고, 항상 뮤텍스를 이용해 Insert 작업을 진행합니다. | 대량 Insert문 진행 중에 다른 Insert가 가능합니다. | 복제 구성된 환경에서는 결과 값이 달라질 수 있으므로 주의해야 됩니다. | . | . | . -- MySQL 8.0 기본값 mysql&gt; show global variables like &#39;%autoinc_lock_mode%&#39;; +--+-+ | Variable_name | Value | +--+-+ | innodb_autoinc_lock_mode | 2 | +--+-+ 1 row in set (0.01 sec) . 격리 수준(Isolation-Level) . 여러 트랜잭션이 동시에 처리될 때, 특정 트랜잭션의 변경/조회 작업을 제어하는 방법입니다. | 총 4개의 단계로 이루어져 있으며 단계가 높아질수록 동시성이 떨어집니다. READ UNCOMMITTED | READ COMMITTED | REPEATABLE READ | SERIALIZABLE | | Isolation Level에 따라 부정합 현상이 발생할 수 있으며, 아래 표와 같습니다. dirty Read: Commit 되지 않은 데이터를 다른 트랜잭션이 조회 가능 | Non Repeatable Read: 동일 트랜잭션 내에서 Select문의 결과가 다름 | Phantom Read: 동일 트랜잭션에서 조회 시 없던 결과가 생김. | . | . Isolation Level에 따른 특징 . READ UNCOMMITTED Commit 여부에 상관없이 다른 트랜잭션 결과를 그대로 조회합니다. | 위에 설명한 세가지 부정합 현상이 모두 발생합니다. | . | . -- Session 1 mysql&gt; SET SESSION transaction isolation level READ UNCOMMITTED; Query OK, 0 rows affected (0.00 sec) mysql&gt; START TRANSACTION; Query OK, 0 rows affected (0.01 sec) mysql&gt; SELECT * FROM next_key; ++++ | A | b | c | ++++ | 1 | 1 | N | | 2 | 4 | S | | 3 | 10 | NULL | | 4 | 11 | Y | | 5 | 14 | Y | ++++ 5 rows in set (0.01 sec) -- Session 2 START TRANSACTION; mysql&gt; START TRANSACTION; Query OK, 0 rows affected (0.01 sec) mysql&gt; DELETE FROM next_key WHERE A=5; Query OK, 1 row affected (0.03 sec) mysql&gt; INSERT next_key (b) VALUES (100); Query OK, 1 row affected (0.02 sec) -- Session 1 (Commit 되지 않은 결과 확인) = Dirty Read mysql&gt; SELECT * FROM next_key; +-+++ | A | b | c | +-+++ | 1 | 1 | N | | 2 | 4 | S | | 3 | 10 | NULL | | 4 | 11 | Y | | 15 | 100 | Y | +-+++ 5 rows in set (0.03 sec) -- Session 2 mysql&gt; ROLLBACK; Query OK, 0 rows affected (0.01 sec) -- Session 1 (동일 트랜잭션 내 변경된 결과: Non-Repeatable Read / 이전에 없던 b=100 생성: Phantom-Read) mysql&gt; SELECT * FROM next_key; ++++ | A | b | c | ++++ | 1 | 1 | N | | 2 | 4 | S | | 3 | 10 | NULL | | 4 | 11 | Y | | 5 | 14 | Y | ++++ 5 rows in set (0.01 sec) . READ COMMITTED 각 명령문마다 Commit 트랜잭션 ID값을 사용해 레코드 버전 제어 | Non Repeatable Read 현상이 발생 (InnoDB에선 Phantom Read 미발생) | 각 명령문마다 자기만의 스냅샷을 소유하여, 정합성을 유지할 수 있음. | Lock이 발생하지 않음 | . | . -- Session 1 mysql&gt; SET SESSION TRANSACTION isolation level READ COMMITTED; Query OK, 0 rows affected (0.01 sec) mysql&gt; START TRANSACTION; Query OK, 0 rows affected (0.01 sec) mysql&gt; SELECT * FROM next_key; ++++ | A | b | c | ++++ | 1 | 1 | N | | 2 | 4 | S | | 3 | 10 | NULL | | 4 | 11 | Y | | 5 | 14 | Y | ++++ 5 rows in set (0.03 sec) -- Session 2 mysql&gt; START TRANSACTION; Query OK, 0 rows affected (0.00 sec) mysql&gt; DELETE FROM next_key WHERE A=5; Query OK, 1 row affected (0.02 sec) mysql&gt; INSERT next_key(B) VALUES (100); Query OK, 1 row affected (0.02 sec) -- Session 1 (동일한 결과 / Dirty Read 방지) mysql&gt; SELECT * FROM next_key; ++++ | A | b | c | ++++ | 1 | 1 | N | | 2 | 4 | S | | 3 | 10 | NULL | | 4 | 11 | Y | | 5 | 14 | Y | ++++ 5 rows in set (0.02 sec) -- Session 2 mysql&gt; COMMIT; -- Session 1 (동일 트랜잭션 내 변경된 결과: Non-Repeatable Read / 이전에 없던 b=100 생성: Phantom-Read) mysql&gt; SELECT * FROM next_key; +-+++ | A | b | c | +-+++ | 1 | 1 | N | | 2 | 4 | S | | 3 | 10 | NULL | | 4 | 11 | Y | | 16 | 100 | Y | +-+++ 5 rows in set (0.02 sec) . REPEATABLE READ MySQL의 기본 isolation level입니다. | 트랜잭션이 시작될 때 스냅샷을 생성하고, 언제나 동일한 결과셋을 읽도록 제어합니다. | 동일 트랜잭션에서 내에서 같은 결과를 읽어와 Phantom READ를 방지하지만, 발생하는 예외 케이스가 존재합니다. (ex) SELECT ~ FOR UPDATE와 같은 조회에 잠금 할당이 필요한 명령문 | . | . | SERIALIZABLE SELECT가 하나의 트랜잭션이며, 조회 시 S-Lock이 할당됩니다. | select문에 영향받는 object에 대해 DML, DDL 불가합니다. | 가장 높은 격리 수준이며, 동시성이 제일 떨어집니다. | . | .",
            "url": "https://martin-son.github.io/Martin-IT-Blog/real%20mysql%208.0/mysql/2022/03/21/Real-Mysql-8.0-%ED%8A%B8%EB%9E%9C%EC%9E%AD%EC%85%98.html",
            "relUrl": "/real%20mysql%208.0/mysql/2022/03/21/Real-Mysql-8.0-%ED%8A%B8%EB%9E%9C%EC%9E%AD%EC%85%98.html",
            "date": " • Mar 21, 2022"
        }
        
    
  
    
        ,"post4": {
            "title": "MySQL 8.0 설치 (Real Mysql 8.0)",
            "content": "Real MySQL 8.0을 공부하며 첫 단계인 MySQL 설치 방법에 대해 정리하려 합니다. 책에서는 간단하게 UI를 통해 설치하는 방법에 대해 자세히 나와 있어 Linux환경에서 커뮤니티 버전을 Binary 파일을 이용하여 설치하는 방법에 대해 정리했습니다. . 설치 방법 . Binary 설치 파일 다운로드 # 다운로드 할 경로에 접근 $ cd /usr/local # binary 파일 다운로드 (8.0.21 버전) $ wget https://downloads.mysql.com/archives/get/p/23/file/mysql-8.0.21-linux-glibc2.12-x86_64.tar.xz # 다운로드 파일 확인 $ ll mysql-8.0* -rw-r--r-- 1 root root 347814208 Jun 17 2020 mysql-8.0.21-linux-glibc2.12-x86_64.tar.xz . | 압축 해제 및 보안을 위한 OS 계정, 그룹 추가 # tar 명령어를 사용하여 압축해제 $ tar -xvf mysql-8.0.21-linux-glibc2.12-x86_64.tar.xz # mysql 그룹 &amp; USER 그룹 추가 $ groupadd mysql $ useradd -r -g mysql -s /bin/false mysql &gt; **옵션 의미** &gt; -r: 시스템 계정 생성 , -g: 세로운 그룹명 -s 새로운 계정의 로그인 Shell &gt; /bin/false: FTP접속 불가, SSH 접속불가 &gt; **mysql 계정 생성 이유** &gt; EC2에 있는 DB 데이터에 불특정 OS계정이 접근하지 못하도록 별도의 계정을 생성하여 보안적으로 관리하기 위함입니다. # Soft Link 연결 $ ln -s mysql-8.0.21-linux-glibc2.12-x86_64 mysql . | MySQL 서버 디렉토리 경로 설정 (Config 정리) ## config 파일 생성 $ vi /etc/my.cnf [mysqld] user=mysql basedir=/usr/local/mysql datadir=/data/mysql socket=/data/mysql.sock # Disabling symbolic-links is recommended to prevent assorted security risks symbolic-links=0 #replication log-bin=/bin_log/mysql-bin server-id=1 #character_set collation-server = utf8mb4_unicode_ci character-set-server = utf8mb4 skip-character-set-client-handshake [mysqld_safe] log-error=/var/log/mysqld.log pid-file=/mysql_data/mysql.pid [client] socket=/data/mysql.sock # include all files from the config directory !includedir /etc/my.cnf.d . | Config 경로 생성 # Data 디렉토리 (/data/mysql) $ mkdir -p /data/mysql $ chown -R mysql.mysql /data # pid 디렉토리 (/mysql_data) $ mkdir -p /mysql_data $ chown mysql.mysql /mysql_data # Bin_log 디렉토리 (/data/bin_log) $ mkdir -p /bin_log $ chown -R mysql:mysql /bin_log . | MySQL 설치 &amp; 기동 #설치파일 경로 접속 $ cd /usr/local/mysql #Mysql Install (Config 파일 미세팅 시, 경로 지정 옵션 필요) $ /usr/local/mysql/bin/mysqld --initialize-insecure #MySQL 기동 $ /usr/local/mysql/bin/mysqld_safe &amp; . [Warning] [MY-010453] [Server] root@localhost is created with an empty password ! Please consider switching off the –initialize-insecure option . –initialize-insecure 옵션으로 Root 계정이 비밀번호가 없어, 보안 상 경고가 나오지만, 비밀번호는 차후에 생성 예정 | . | MySQL 명령어 설정 &amp; 접속 # Mysql 명령어를 Location 관계없이 사용할 수 있도록 설정 $ sudo vi /etc/profile # 맨 하단으로 이동하여 아래 내용 추가 export DB_HOME=/usr/local/mysql export PATH=&quot;$PATH:/usr/local/mysql/bin&quot; # 해당 내용 저장 후 아래 명령어 실행 $ source /etc/profile # Mysql 접속 mysql -uroot . 접속 에러 발생 시 해결 방법 . error while loading shared libraries: libncurses.so.5 | error while loading shared libraries: libtinfo.so.5 # 에러메시지에 출력된 파일 형식과 다른 버전이 있는지 탐색 $ cd / $ find | grep libtinfo # Soft Link를 통해 해당 에러메시지 파일 대신 결과로 도출된 파일 바라보도록 설정 ## 결과창에 다음과 같은 경로로 나왔다고 가정 (/usr/lib64/libtinfo.so.6) $ ln -s /usr/lib64/libncurses.so.6 /usr/lib64/libncurses.so.5 $ ln -s /usr/lib64/libtinfo.so.6 /usr/lib64/libtinfo.so.5 . | | root 비밀번호 설정 mysql&gt; ALTER USER &#39;root&#39;@&#39;localhost&#39; IDENTIFIED BY &#39;[비밀번호]&#39;; Query OK, 0 rows affected (0.00 sec) . ​ . |",
            "url": "https://martin-son.github.io/Martin-IT-Blog/real%20mysql%208.0/mysql/2022/03/13/Real-Mysql-8.0-%EC%84%A4%EC%B9%98.html",
            "relUrl": "/real%20mysql%208.0/mysql/2022/03/13/Real-Mysql-8.0-%EC%84%A4%EC%B9%98.html",
            "date": " • Mar 13, 2022"
        }
        
    
  
    
        ,"post5": {
            "title": "외래키, 성능에 어떤 영향을 미칠까?",
            "content": "외래키 (Foreign Key)란? . 외래키는 MySQL에서 기본 엔진으로 사용되는 InnoDB 스토리지 엔진에서만 사용 가능한 제약조건입니다. 외래키는 서로 다른 테이블 간 부모-자식 관계를 정의하여, 데이터 변경이 발생하면 정의한 제약조건에 따라 함께 영향을 받는 특징을 가지고 있습니다. 또한, 부모-자식 관계로 정의된 컬럼에 대해 자동으로 인덱스가 생성됩니다. . 외래키의 특징 . 데이터베이스에서 DML을 통해 데이터 변경이 발생하면, Lock을 소유하게 됩니다. 일반적으로 외래키 제약조건이 없는 테이블이라면, 다른 테이블에 대한 DML에 대해서는 Lock으로 인해 대기하지 않습니다. . 하지만, 외래키 제약조건이 있는 테이블의 경우, 부모-자식 관계로 정의된 컬럼에 대해서 두 테이블 데이터가 일치해야 하기 때문에, 외래키로 정의된 동일 데이터에 대해 DML 작업이 발생하게 되면, Lock으로 인해 대기해야 하는 상황이 발생합니다. 위 상황을 간단한 아래 테스트를 통해 확인해 볼 수 있습니다. . -- 외래키 제약조건을 가진 테스트 테이블 A, B 생성 mysql&gt; CREATE TABLE parent_fk ( id int AUTO_INCREMENT PRIMARY KEY, name varchar(10), age int NOT NULL, INDEX ix_name_age (name, age) ); Query OK, 0 rows affected (0.04 sec) mysql&gt; CREATE TABLE child_fk ( id int AUTO_INCREMENT PRIMARY KEY, p_name varchar(10), product varchar(15), p_age int(11), FOREIGN KEY (p_name, p_age) REFERENCES parent_fk (name, age) ON DELETE CASCADE ON UPDATE CASCADE ); Query OK, 0 rows affected (0.05 sec) -- 테스트 데이터 Insert mysql&gt; INSERT parent_fk (name, age) VALUES (&#39;Tom&#39;, 11), (&#39;Martin&#39;, 29), (&#39;David&#39;, 17), (&#39;Grek&#39;, 40), (&#39;Lucy&#39;, 26); Query OK, 5 rows affected (0.02 sec) Records: 5 Duplicates: 0 Warnings: 0 -- 외래키 제약조건 상 데이터 정합성을 유지하기 위해 부모 테이블에 없는 데이터 Insert 시 에러 발생. mysql&gt; INSERT child_fk (p_name, product, p_age) VALUES (&#39;Tom&#39;, &#39;TV&#39;, 13); ERROR 1452 (23000): Cannot add or update a child row: a foreign key constraint fails (`blog_test`.`child_fk`, CONSTRAINT `child_fk_ibfk_1` FOREIGN KEY (`p_name`, `p_age`) REFERENCES `parent_fk` (`name`, `age`) ON DELETE CASCADE ON UPDATE CASCADE) mysql&gt; INSERT child_fk (p_name, product, p_age) VALUES (&#39;Tom&#39;, &#39;TV&#39;, 11); Query OK, 1 row affected (0.03 sec) -- 데이터 확인 mysql&gt; SELECT * FROM parent_fk; +-+--+--+ | id | name | age | +-+--+--+ | 3 | David | 17 | | 4 | Grek | 40 | | 5 | Lucy | 26 | | 2 | Martin | 29 | | 1 | Tom | 11 | +-+--+--+ 5 rows in set (0.01 sec) mysql&gt; SELECT * FROM child_fk; +-+--++-+ | id | p_name | product | p_age | +-+--++-+ | 2 | Tom | TV | 11 | | 4 | David | Desk | 17 | +-+--++-+ 2 rows in set (0.01 sec) . 시간 세션 1 세션 2 비고 . 1 | START TRANSACTION; |   |   | . 2 | UPDATE parent_fk SET age=80 WHERE name = &#39;Tom&#39;; |   | name=’Tom’인 부모테이블의 age 컬럼 업데이트 update | . 3 |   | START TRANSACTION; |   | . 4 |   | UPDATE child_fk SET product = &#39;Notebook&#39; WHERE p_name = &#39;Tom&#39;; | 자식 테이블의 name=’Tom’ product 컬럼 update | . 5 |   | ERROR 1205 (HY000): Lock wait timeout exceeded; try restarting transaction | Lock으로 인해 wait_timeout 만큼 대기 후 에러 로그 발생 | . 외래키의 성능 . 위의 테스트 결과에서 확인할 수 있듯이, 외래키 제약 조건이 있으면 Lock을 통해 제약 조건을 만족할 수 있도록 제어합니다. 외래키에 대한 DML이 다량으로 발생하게 되면 그만큼 확인 작업도 증가하게 될테니 성능에 어떤 영향을 주는지 의문이 들었습니다. . 그래서 sysbench 툴을 이용해 2개의 부모-자식 관계 테이블을 생성하고 외래키에 대한 update문을 실행하도록 하여 스레드별 성능 테스트를 진행했습니다. . 테스트를 위한 데이터 준비는 아래 스크립트를 이용하여 만들었습니다. . # sysbench툴을 이용한 테스트 테이블 생성 ## 1억건 테이블 2개 / 약 21GB /usr/local/sysbench/share/sysbench/oltp_read_write.lua --mysql-host=&#39;[호스트 정보]&#39; --mysql-port=[Port 번호] --mysql-user=master --mysql-password=&#39;[비밀번호]&#39; --mysql-db=sbtest --db-driver=mysql --tables=2 --table-size=100000000 --threads=128 prepare . 위에서 준비한 테이블에 외래키 제약조건을 테스트할, 컬럼을 추가해주고 외래키 제약조건을 생성합니다. . -- 부모테이블에 외래키 제약조건 생성을 위한, 컬럼추가 &amp; 인덱스 추가 mysql&gt; ALTER TABLE sbtest1 ADD foreign_column char(100) DEFAULT &#39;test_for_foreign_key&#39;, ADD INDEX ix_foreign_column(foreign_column), ALGORITHM = INPLACE, LOCK=NONE; -- 자식테이블에 컬럼 추가 &amp; 외래키 제약조건 추가 mysql&gt; ALTER TABLE sbtest2 ADD foreign_column char(100), ADD CONSTRAINT fk_test FOREIGN KEY (foreign_column) REFERENCES sbtest1 (foreign_column) ON UPDATE CASCADE; . 외래키 성능 테스트를 위한 테이블 스키마 사전 준비는 위 과정을 통해 모두 끝냈습니다. 이후 기본 sysbench 테스트 툴에는 수동으로 생성한 외래키 컬럼에 대한 DML문이 실행되지 않기 때문에, 수정이 필요합니다. . # update index 옵션 사용 시, 실행되는 update문을 변경 () $ cp [경로]/oltp_common.lua [경로]/oltp_common_backup.txt $ vi [경로]/oltp_common.lua # 아래 구문 수정 #index_updates = { # &quot;UPDATE sbtest%u SET k=k+1 WHERE id=?&quot;, # t.INT}, index_updates = { &quot;UPDATE sbtest1 SET foreign_column=(case floor(rand()*5) when 0 then &#39;abc&#39; when 1 then &#39;czcz&#39; when 2 then &#39;sotq&#39; end) WHERE id=?&quot;, t.INT}, . 위와 같이 수정 후, 아래 스크립트문을 준비하여 동시 실행 스레드 수별 성능 차이를 테스트해봅니다. 테스트는 아래와 같은 MySQL 환경에서 진행했습니다. . 버전: 5.7.mysql_aurora.2.09.2 | 인스턴스 스펙: db.r6g.xlarge | . # $ vi test.sh /usr/local/sysbench/bin/sysbench /usr/local/sysbench/share/sysbench/oltp_read_write.lua --mysql-host=&#39;[접속 호스트명]&#39; --mysql-port=[Port번호] --mysql-user=master --mysql-password=&#39;[비밀번호]&#39; --index_updates=50 --mysql-db=sbtest_foreign --db-driver=mysql --threads=[병렬 실행 Thread수] --forced-shutdown --tables=2 --report-interval=1 --max-time=120 run . 외래키 제약조건이 있는 상태에서 스레드별 결과를 확인 후, 제약조건을 제거합니다. . -- 외래키 제약조건 제거 mysql&gt; ALTER TABLE sbtest2 DROP FOREIGN KEY fk_test; Query OK, 0 rows affected (0.05 sec) -- sysbench 스크립트 병렬 스레드 갯수를 조절해가며 이전 결과와 비교 진행. . sysbench를 이용하여, 외래키 관계에 있는 컬럼에 대한 update를 실행하도록 조절했습니다. 그에 대한 성능 결과는 아래와 같습니다. . . 병렬 스레드 갯수와 무관하게, 전체적으로 외래키 제약조건이 존재할 경우, QPS는 감소하고 Latency는 증가하는 현상을 확인할 수 있습니다. DBA로서 외래키 제약조건을 여러 이유로 최대한 지양 (성능 저하, DDL/DML시 관리포인트 증가)해야 하는 사실은 인지만 했었는데, 간단한 테스트를 통해 성능 저하를 확인할 수 있어 좋은 경험이었습니다. .",
            "url": "https://martin-son.github.io/Martin-IT-Blog/mysql/foreign%20key/performance/2022/02/28/foreign-key-Performance.html",
            "relUrl": "/mysql/foreign%20key/performance/2022/02/28/foreign-key-Performance.html",
            "date": " • Feb 28, 2022"
        }
        
    
  

  
  

  
      ,"page1": {
          "title": "About Me",
          "content": "This website is powered by fastpages 1. . a blogging platform that natively supports Jupyter notebooks in addition to other formats. &#8617; . |",
          "url": "https://martin-son.github.io/Martin-IT-Blog/about/",
          "relUrl": "/about/",
          "date": ""
      }
      
  

  

  
      ,"page3": {
          "title": "",
          "content": ". . 더 나은 IT 역량을 쌓기 위해 개인적인 테스트 및 실습 기록을 공유하는 블로그입니다. | . Study Category . . Posts .",
          "url": "https://martin-son.github.io/Martin-IT-Blog/",
          "relUrl": "/",
          "date": ""
      }
      
  

  
  

  

  
  

  

  
  

  
  

}